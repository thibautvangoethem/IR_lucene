<head>
<style>
td, th {
  border: 1px solid #dddddd;
  text-align: left;
  padding: 8px;
}
</style>
</head><h1>Why don't Java's +=, -=, *=, /= compound assignment operators require casting?</h1><p>Until today, I thought that for example:</p>

<pre><code>i += j;
</code></pre>

<p>Was just a shortcut for:</p>

<pre><code>i = i + j;
</code></pre>

<p>But if we try this:</p>

<pre><code>int i = 5;
long j = 8;
</code></pre>

<p>Then <code>i = i + j;</code> will not compile but <code>i += j;</code> will compile fine.</p>

<p>Does it mean that in fact <code>i += j;</code> is a shortcut for something like this
<code>i = (type of i) (i + j)</code>?</p>
<table> <tr><th>answers</th></tr><tr><td><p>As always with these questions, the JLS holds the answer. In this case <a href="http://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.26.2" rel="noreferrer">§15.26.2 Compound Assignment Operators</a>. An extract:</p>

<blockquote>
  <p>A compound assignment expression of the form <code>E1&nbsp;op=&nbsp;E2</code> is equivalent to <code>E1&nbsp;=&nbsp;(T)((E1)&nbsp;op&nbsp;(E2))</code>, where <code>T</code> is the type of <code>E1</code>, except that <code>E1</code> is evaluated only once.</p>
</blockquote>

<p>An example cited from <a href="http://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html#jls-15.26.2" rel="noreferrer">§15.26.2</a></p>

<blockquote>
  <p>[...] the following code is correct:</p>

<pre><code>short x = 3;
x += 4.6;
</code></pre>
  
  <p>and results in x having the value 7 because it is equivalent to:</p>

<pre><code>short x = 3;
x = (short)(x + 4.6);
</code></pre>
</blockquote>

<p>In other words, your assumption is correct.</p>
</tr></td><tr><td><p>you need to cast from <code>long</code> to <code>int</code> <code>explicitly</code> in case of <code>i = i + l</code>  then it will compile and give correct output. like </p>

<pre><code>i = i + (int)l;
</code></pre>

<p>or</p>

<pre><code>i = (int)((long)i + l); // this is what happens in case of += , dont need (long) casting since upper casting is done implicitly.
</code></pre>

<p>but in case of <code>+=</code> it just works fine because the operator implicitly does the type casting from type of right variable to type of left variable so need not cast explicitly.</p>
</tr></td><tr><td><p>Very good question. The <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.26.2" rel="noreferrer">Java Language specification</a> confirms your suggestion.</p>

<blockquote>
  <p>For example, the following code is correct:</p>

<pre><code>short x = 3;
x += 4.6;
</code></pre>
  
  <p>and results in x having the value 7 because it is equivalent to:</p>

<pre><code>short x = 3;
x = (short)(x + 4.6);
</code></pre>
</blockquote>
</tr></td><tr><td><p>Yes,</p>

<p>basically when we write</p>

<pre><code>i += l; 
</code></pre>

<p>the compiler converts this to </p>

<pre><code>i = (int)(i + l);
</code></pre>

<p>I just checked the <code>.class</code> file code.</p>

<p>Really a good thing to know</p>
</tr></td><tr><td><p>A good example of this casting is using *= or /=</p>

<pre><code>byte b = 10;
b *= 5.7;
System.out.println(b); // prints 57
</code></pre>

<p>or</p>

<pre><code>byte b = 100;
b /= 2.5;
System.out.println(b); // prints 40
</code></pre>

<p>or</p>

<pre><code>char ch = '0';
ch *= 1.1;
System.out.println(ch); // prints '4'
</code></pre>

<p>or</p>

<pre><code>char ch = 'A';
ch *= 1.5;
System.out.println(ch); // prints 'a'
</code></pre>
</tr></td><tr><td><p>The problem here involves type casting.</p>

<p>When you add int and long, </p>

<ol>
<li>The int object is casted to long &amp; both are added and you get long object.</li>
<li>but long object cannot be implicitly casted to int. So, you have to do that explicitly.</li>
</ol>

<p>But <code>+=</code> is coded in such a way that it does type casting. <code>i=(int)(i+m)</code></p>
</tr></td><tr><td><p>In Java type conversions are performed automatically when the type of the expression on the right hand side of an assignment operation can be safely promoted to the type of the variable on the left hand side of the assignment. Thus we can safely assign:  </p>

<pre> byte -> short -> int -> long -> float -> double. </pre>  

<p>The same will not work the other way round. For example we cannot automatically convert a long to an int because the first requires more storage than the second and consequently information may be lost. To force such a conversion we must carry out an explicit conversion.<br>
<a href="http://way2java.com/casting-operations/data-type-casting-type-conversion/" rel="noreferrer">Type - Conversion</a></p>
</tr></td><tr><td><p>Sometimes, such a question can be asked at an interview.</p>

<p>For example, when you write:</p>

<pre><code>int a = 2;
long b = 3;
a = a + b;
</code></pre>

<p>there is no automatic typecasting. In C++ there will not be any error compiling the above code, but in Java you will get something like <code>Incompatible type exception</code>.</p>

<p>So to avoid it, you must write your code like this:</p>

<pre><code>int a = 2;
long b = 3;
a += b;// No compilation error or any exception due to the auto typecasting
</code></pre>
</tr></td><tr><td><p>Subtle point here...</p>

<p>There is an implicit typecast for <code>i+j</code> when <code>j</code> is a double and <code>i</code> is an int.
Java <strong>ALWAYS</strong> converts an integer into a double when there is an operation between them.</p>

<p>To clarify <code>i+=j</code> where <code>i</code> is an integer and <code>j</code> is a double can be described as</p>

<pre><code>i = &lt;int&gt;(&lt;double&gt;i + j)
</code></pre>

<p>See: <a href="https://www.cs.cmu.edu/~pattis/15-1XX/15-200/lectures/voe/lecture.html#ImplicitConversion" rel="noreferrer">this description of implicit casting</a></p>

<p>You might want to typecast <code>j</code> to <code>(int)</code> in this case for clarity.</p>
</tr></td><tr><td><p>The main difference is that with <code>a = a + b</code>, there is no typecasting going on, and so the compiler gets angry at you for not typecasting. But with <code>a += b</code>, what it's really doing is typecasting <code>b</code> to a type compatible with <code>a</code>. So if you do </p>

<pre><code>int a=5;
long b=10;
a+=b;
System.out.println(a);
</code></pre>

<p>What you're really doing is: </p>

<pre><code>int a=5;
long b=10;
a=a+(int)b;
System.out.println(a);
</code></pre>
</tr></td><tr><td><p>Java Language Specification <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.26.2" rel="noreferrer">defines <code>E1 op= E2</code> to be equivalent to <code>E1 = (T) ((E1) op (E2))</code> where <code>T</code> is a type of <code>E1</code> and <code>E1</code> is evaluated once</a>.</p>

<p>That's a technical answer, but you may be wondering why that's a case. Well, let's consider the following program.</p>

<pre><code>public class PlusEquals {
    public static void main(String[] args) {
        byte a = 1;
        byte b = 2;
        a = a + b;
        System.out.println(a);
    }
}
</code></pre>

<p>What does this program print?</p>

<p>Did you guess 3? Too bad, this program won't compile. Why? Well, it so happens that addition of bytes in Java <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.6.2" rel="noreferrer">is defined to return an <code>int</code></a>. This, I believe was because the Java Virtual Machine doesn't define byte operations to save on bytecodes (there is a limited number of those, after all), using integer operations instead is an implementation detail exposed in a language.</p>

<p>But if <code>a = a + b</code> doesn't work, that would mean <code>a += b</code> would never work for bytes if it <code>E1 += E2</code> was defined to be <code>E1 = E1 + E2</code>. As the previous example shows, that would be indeed the case. As a hack to make <code>+=</code> operator work for bytes and shorts, there is an implicit cast involved. It's not that great of a hack, but back during the Java 1.0 work, the focus was on getting the language released to begin with. Now, because of backwards compatibility, this hack introduced in Java 1.0 couldn't be removed.</p>
</tr></td>
<head>
<style>
td, th {
  border: 1px solid #dddddd;
  text-align: left;
  padding: 8px;
}
</style>
</head><h1>For-each over an array in JavaScript</h1><p>How can I loop through all the entries in an array using JavaScript?</p>

<p>I thought it was something like this:</p>

<pre><code>forEach(instance in theArray)
</code></pre>

<p>Where <code>theArray</code> is my array, but this seems to be incorrect.</p>
<table> <tr><th>answers</th></tr><tr><td>

<p><strong>TL;DR</strong></p>

<ul>
<li>Don't use <code>for-in</code> unless you use it with safeguards or are at least aware of why it might bite you.</li>
<li><p>Your best bets are usually</p>

<ul>
<li>a <code>for-of</code> loop (ES2015+ only),</li>
<li><code>Array#forEach</code> (<a href="https://tc39.github.io/ecma262/#sec-array.prototype.foreach" rel="noreferrer"><code>spec</code></a> | <a href="https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach" rel="noreferrer"><code>MDN</code></a>) (or its relatives <code>some</code> and such) (ES5+ only),</li>
<li>a simple old-fashioned <code>for</code> loop,</li>
<li>or <code>for-in</code> with safeguards.</li>
</ul></li>
</ul>

<p>But there's <strong>lots</strong> more to explore, read on...</p>

<hr>

<p>JavaScript has powerful semantics for looping through arrays and array-like objects. I've split the answer into two parts: Options for genuine arrays, and options for things that are just array-<em>like</em>, such as the <code>arguments</code> object, other iterable objects (ES2015+), DOM collections, and so on.</p>

<p>I'll quickly note that you can use the ES2015 options <em>now</em>, even on ES5 engines, by <em>transpiling</em> ES2015 to ES5. Search for "ES2015 transpiling" / "ES6 transpiling" for more...</p>

<p>Okay, let's look at our options:</p>

<h2>For Actual Arrays</h2>

<p>You have three options in <a href="http://ecma-international.org/ecma-262/5.1/" rel="noreferrer">ECMAScript&nbsp;5</a> ("ES5"), the version most broadly supported at the moment, and two more added in <a href="http://www.ecma-international.org/ecma-262/6.0/index.html" rel="noreferrer">ECMAScript&nbsp;2015</a> ("ES2015", "ES6"):</p>

<ol>
<li>Use <code>forEach</code> and related (ES5+)</li>
<li>Use a simple <code>for</code> loop</li>
<li>Use <code>for-in</code> <em>correctly</em></li>
<li>Use <code>for-of</code> (use an iterator implicitly) (ES2015+)</li>
<li>Use an iterator explicitly (ES2015+)</li>
</ol>

<p>Details:</p>

<h3>1. Use <code>forEach</code> and related</h3>

<p>In any vaguely-modern environment (so, not IE8) where you have access to the <code>Array</code> features added by ES5 (directly or using polyfills), you can use <code>forEach</code> (<a href="https://tc39.github.io/ecma262/#sec-array.prototype.foreach" rel="noreferrer"><code>spec</code></a> | <a href="https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach" rel="noreferrer"><code>MDN</code></a>):</p>

<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>var a = ["a", "b", "c"];
a.forEach(function(entry) {
    console.log(entry);
});</code></pre>
</div>
</div>
</p>

<p><code>forEach</code> accepts a callback function and, optionally, a value to use as <code>this</code> when calling that callback (not used above). The callback is called for each entry in the array, in order, skipping non-existent entries in sparse arrays. Although I only used one argument above, the callback is called with three: The value of each entry, the index of that entry, and a reference to the array you're iterating over (in case your function doesn't already have it handy).</p>

<p>Unless you're supporting obsolete browsers like IE8 (which NetApps shows at just over 4% market share as of this writing in September&nbsp;2016), you can happily use <code>forEach</code> in a general-purpose web page without a shim. If you do need to support obsolete browsers, shimming/polyfilling <code>forEach</code> is easily done (search for "es5 shim" for several options).</p>

<p><code>forEach</code> has the benefit that you don't have to declare indexing and value variables in the containing scope, as they're supplied as arguments to the iteration function, and so nicely scoped to just that iteration.</p>

<p>If you're worried about the runtime cost of making a function call for each array entry, don't be; <a href="http://blog.niftysnippets.org/2012/02/foreach-and-runtime-cost.html" rel="noreferrer">details</a>.</p>

<p>Additionally, <code>forEach</code> is the "loop through them all" function, but ES5 defined several other useful "work your way through the array and do things" functions, including:</p>

<ul>
<li><a href="https://tc39.github.io/ecma262/#sec-array.prototype.every" rel="noreferrer"><code>every</code></a> (stops looping the first time the callback returns <code>false</code> or something falsey)</li>
<li><a href="https://tc39.github.io/ecma262/#sec-array.prototype.some" rel="noreferrer"><code>some</code></a> (stops looping the first time the callback returns <code>true</code> or something truthy)</li>
<li><a href="https://tc39.github.io/ecma262/#sec-array.prototype.filter" rel="noreferrer"><code>filter</code></a> (creates a new array including elements where the filter function returns <code>true</code> and omitting the ones where it returns <code>false</code>)</li>
<li><a href="https://tc39.github.io/ecma262/#sec-array.prototype.map" rel="noreferrer"><code>map</code></a> (creates a new array from the values returned by the callback)</li>
<li><a href="https://tc39.github.io/ecma262/#sec-array.prototype.reduce" rel="noreferrer"><code>reduce</code></a> (builds up a value by repeatedly calling the callback, passing in previous values; see the spec for the details; useful for summing the contents of an array and many other things)</li>
<li><a href="https://tc39.github.io/ecma262/#sec-array.prototype.reduceright" rel="noreferrer"><code>reduceRight</code></a> (like <code>reduce</code>, but works in descending rather than ascending order)</li>
</ul>

<h3>2. Use a simple <code>for</code> loop</h3>

<p>Sometimes the old ways are the best:</p>

<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>var index;
var a = ["a", "b", "c"];
for (index = 0; index &lt; a.length; ++index) {
    console.log(a[index]);
}</code></pre>
</div>
</div>
</p>

<p>If the length of the array won't change during the loop, and it's in performance-sensitive code (unlikely), a slightly more complicated version grabbing the length up front might be a <strong><em>tiny</em></strong> bit faster:</p>

<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>var index, len;
var a = ["a", "b", "c"];
for (index = 0, len = a.length; index &lt; len; ++index) {
    console.log(a[index]);
}</code></pre>
</div>
</div>
</p>

<p>And/or counting backward:</p>

<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>var index;
var a = ["a", "b", "c"];
for (index = a.length - 1; index &gt;= 0; --index) {
    console.log(a[index]);
}</code></pre>
</div>
</div>
</p>

<p>But with modern JavaScript engines, it's rare you need to eke out that last bit of juice.</p>

<p>In ES2015 and higher, you can make your index and value variables local to the <code>for</code> loop:</p>

<pre><code>let a = ["a", "b", "c"];
for (let index = 0; index &lt; a.length; ++index) {
    let value = a[index];
    console.log(index, value);
}
//console.log(index);   // would cause "ReferenceError: index is not defined"
//console.log(value);   // would cause "ReferenceError: value is not defined"
</code></pre>

<p><div class="snippet" data-lang="js" data-hide="true" data-console="true" data-babel="false">
<div class="snippet-code snippet-currently-hidden">
<pre class="snippet-code-js lang-js prettyprint-override"><code>let a = ["a", "b", "c"];
for (let index = 0; index &lt; a.length; ++index) {
    let value = a[index];
    console.log(index, value);
}
try {
    console.log(index);
} catch (e) {
    console.error(e);   // "ReferenceError: index is not defined"
}
try {
    console.log(value);
} catch (e) {
    console.error(e);   // "ReferenceError: value is not defined"
}</code></pre>
</div>
</div>
</p>

<p>And when you do that, not just <code>value</code> but also <code>index</code> is recreated for each loop iteration, meaning closures created in the loop body keep a reference to the <code>index</code> (and <code>value</code>) created for that specific iteration:</p>

<pre><code>let divs = document.querySelectorAll("div");
for (let index = 0; index &lt; divs.length; ++index) {
    divs[index].addEventListener('click', e =&gt; {
        console.log("Index is: " + index);
    });
}
</code></pre>

<p><div class="snippet" data-lang="js" data-hide="true" data-console="true" data-babel="false">
<div class="snippet-code snippet-currently-hidden">
<pre class="snippet-code-js lang-js prettyprint-override"><code>let divs = document.querySelectorAll("div");
for (let index = 0; index &lt; divs.length; ++index) {
    divs[index].addEventListener('click', e =&gt; {
        console.log("Index is: " + index);
    });
}</code></pre>
<pre class="snippet-code-html lang-html prettyprint-override"><code>&lt;div&gt;zero&lt;/div&gt;
&lt;div&gt;one&lt;/div&gt;
&lt;div&gt;two&lt;/div&gt;
&lt;div&gt;three&lt;/div&gt;
&lt;div&gt;four&lt;/div&gt;</code></pre>
</div>
</div>
</p>

<p>If you had five divs, you'd get "Index is: 0" if you clicked the first and "Index is: 4" if you clicked the last. This does <strong>not</strong> work if you use <code>var</code> instead of <code>let</code>.</p>

<h3>3. Use <code>for-in</code> <em>correctly</em></h3>

<p>You'll get people telling you to use <code>for-in</code>, but <a href="http://blog.niftysnippets.org/2010/11/myths-and-realities-of-forin.html" rel="noreferrer">that's not what <code>for-in</code> is for</a>. <code>for-in</code> loops through the <em>enumerable properties of an object</em>, not the indexes of an array. <strong>The order is not guaranteed</strong>, not even in ES2015 (ES6). ES2015+ does define an order to object properties (via <a href="https://tc39.github.io/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots-ownpropertykeys" rel="noreferrer"><code>[[OwnPropertyKeys]]</code></a>, <a href="https://tc39.github.io/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots-enumerate" rel="noreferrer"><code>[[Enumerate]]</code></a>, and things that use them like <a href="https://tc39.github.io/ecma262/#sec-object.getownpropertynames" rel="noreferrer"><code>Object.getOwnPropertyKeys</code></a>), but it didn't define that <code>for-in</code> would follow that order; ES2020 did, though. (Details in <a href="https://stackoverflow.com/a/30919039/157247">this other answer</a>.)</p>

<p>The only real use cases for <code>for-in</code> on an array are:</p>

<ul>
<li>It's a <a href="http://en.wikipedia.org/wiki/Sparse_array" rel="noreferrer"><em>sparse</em> arrays</a> with <strong>massive</strong> gaps in it, or</li>
<li>You're using non-element properties and you want to include them in the loop</li>
</ul>

<p>Looking only at that first example: You can use <code>for-in</code> to visit those sparse array elements if you use appropriate safeguards:</p>

<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>// `a` is a sparse array
var key;
var a = [];
a[0] = "a";
a[10] = "b";
a[10000] = "c";
for (key in a) {
    if (a.hasOwnProperty(key)  &amp;&amp;        // These checks are
        /^0$|^[1-9]\d*$/.test(key) &amp;&amp;    // explained
        key &lt;= 4294967294                // below
        ) {
        console.log(a[key]);
    }
}</code></pre>
</div>
</div>
</p>

<p>Note the three checks:</p>

<ol>
<li><p>That the object has its <em>own</em> property by that name (not one it inherits from its prototype), and</p></li>
<li><p>That the key is all decimal digits (e.g., normal string form, not scientific notation), and</p></li>
<li><p>That the key's value when coerced to a number is &lt;= 2^32 - 2 (which is 4,294,967,294). Where does that number come from? It's part of the definition of an array index <a href="https://tc39.github.io/ecma262/#array-index" rel="noreferrer">in the specification</a>. Other numbers (non-integers, negative numbers, numbers greater than 2^32 - 2) are not array indexes. The reason it's 2^32 - <strong>2</strong> is that that makes the greatest index value one lower than 2^32 - <strong>1</strong>, which is the maximum value an array's <code>length</code> can have. (E.g., an array's length fits in a 32-bit unsigned integer.) <em>(Props to RobG for pointing out in a comment <a href="http://blog.niftysnippets.org/2010/11/myths-and-realities-of-forin.html" rel="noreferrer">on my blog post</a> that my previous test wasn't quite right.)</em></p></li>
</ol>

<p>You wouldn't do that in inline code, of course. You'd write a utility function. Perhaps:</p>

<p><div class="snippet" data-lang="js" data-hide="true" data-console="true" data-babel="false">
<div class="snippet-code snippet-currently-hidden">
<pre class="snippet-code-js lang-js prettyprint-override"><code>// Utility function for antiquated environments without `forEach`
var hasOwn = Object.prototype.hasOwnProperty;
var rexNum = /^0$|^[1-9]\d*$/;
function sparseEach(array, callback, thisArg) {
    var index;
    for (var key in array) {
        index = +key;
        if (hasOwn.call(a, key) &amp;&amp;
            rexNum.test(key) &amp;&amp;
            index &lt;= 4294967294
            ) {
            callback.call(thisArg, array[key], index, array);
        }
    }
}

var a = [];
a[5] = "five";
a[10] = "ten";
a[100000] = "one hundred thousand";
a.b = "bee";

sparseEach(a, function(value, index) {
    console.log("Value at " + index + " is " + value);
});</code></pre>
</div>
</div>
</p>

<h3>4. Use <code>for-of</code> (use an iterator implicitly) (ES2015+)</h3>

<p>ES2015 added <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols" rel="noreferrer"><em>iterators</em></a> to JavaScript. The easiest way to use iterators is the new <code>for-of</code> statement. It looks like this:</p>

<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>const a = ["a", "b", "c"];
for (const val of a) {
    console.log(val);
}</code></pre>
</div>
</div>
</p>

<p>Under the covers, that gets an <em>iterator</em> from the array and loops through it, getting the values from it. This doesn't have the issue that using <code>for-in</code> has, because it uses an iterator defined by the object (the array), and arrays define that their iterators iterate through their <em>entries</em> (not their properties). Unlike <code>for-in</code> in ES5, the order in which the entries are visited is the numeric order of their indexes.</p>

<h3>5. Use an iterator explicitly (ES2015+)</h3>

<p>Sometimes, you might want to use an <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols" rel="noreferrer">iterator</a> <em>explicitly</em>. You can do that, too, although it's a lot clunkier than <code>for-of</code>. It looks like this:</p>

<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>const a = ["a", "b", "c"];
const it = a.values();
let entry;
while (!(entry = it.next()).done) {
    console.log(entry.value);
}</code></pre>
</div>
</div>
</p>

<p>The iterator is an object matching the Iterator definition in the specification. Its <code>next</code> method returns a new <em>result object</em> each time you call it. The result object has a property, <code>done</code>, telling us whether it's done, and a property <code>value</code> with the value for that iteration. (<code>done</code> is optional if it would be <code>false</code>, <code>value</code> is optional if it would be <code>undefined</code>.)</p>

<p>The meaning of <code>value</code> varies depending on the iterator; arrays support (at least) three functions that return iterators:</p>

<ul>
<li><code>values()</code>: This is the one I used above. It returns an iterator where each <code>value</code> is the array entry for that iteration (<code>"a"</code>, <code>"b"</code>, and <code>"c"</code> in the example earlier).</li>
<li><code>keys()</code>: Returns an iterator where each <code>value</code> is the key for that iteration (so for our <code>a</code> above, that would be <code>"0"</code>, then <code>"1"</code>, then <code>"2"</code>).</li>
<li><code>entries()</code>: Returns an iterator where each <code>value</code> is an array in the form <code>[key, value]</code> for that iteration.</li>
</ul>

<h2>For Array-Like Objects</h2>

<p>Aside from true arrays, there are also <em>array-like</em> objects that have a <code>length</code> property and properties with numeric names: <code>NodeList</code> instances, the <code>arguments</code> object, etc. How do we loop through their contents?</p>

<h3>Use any of the options above for arrays</h3>

<p>At least some, and possibly most or even all, of the array approaches above frequently apply equally well to array-like objects:</p>

<ol>
<li><p><strong>Use <code>forEach</code> and related (ES5+)</strong></p>

<p>The various functions on <code>Array.prototype</code> are "intentionally generic" and can usually be used on array-like objects via <a href="https://tc39.github.io/ecma262/#sec-function.prototype.call" rel="noreferrer"><code>Function#call</code></a> or <a href="https://tc39.github.io/ecma262/#sec-function.prototype.apply" rel="noreferrer"><code>Function#apply</code></a>. (See the <em>Caveat for host-provided objects</em> at the end of this answer, but it's a rare issue.)</p>

<p>Suppose you wanted to use <code>forEach</code> on a <code>Node</code>'s <code>childNodes</code> property. You'd do this:</p>

<pre><code>Array.prototype.forEach.call(node.childNodes, function(child) {
    // Do something with `child`
});
</code></pre>

<p>If you're going to do that a lot, you might want to grab a copy of the function reference into a variable for reuse, e.g.:</p>

<pre><code>// (This is all presumably in some scoping function)
var forEach = Array.prototype.forEach;

// Then later...
forEach.call(node.childNodes, function(child) {
    // Do something with `child`
});
</code></pre></li>
<li><p><strong>Use a simple <code>for</code> loop</strong></p>

<p>Obviously, a simple <code>for</code> loop applies to array-like objects.</p></li>
<li><p><strong>Use <code>for-in</code> <em>correctly</em></strong></p>

<p><code>for-in</code> with the same safeguards as with an array should work with array-like objects as well; the caveat for host-provided objects on #1 above may apply.</p></li>
<li><p><strong>Use <code>for-of</code> (use an iterator implicitly) (ES2015+)</strong></p>

<p><code>for-of</code> uses the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols" rel="noreferrer">iterator</a> provided by the object (if any). That includes host-provided objects. For instance, the specification for the <code>NodeList</code> from <code>querySelectorAll</code> was updated to support iteration. The spec for the <code>HTMLCollection</code> from <code>getElementsByTagName</code> was not.</p></li>
<li><p><strong>Use an iterator explicitly (ES2015+)</strong></p>

<p>See #4.</p></li>
</ol>

<h3>Create a true array</h3>

<p>Other times, you may want to convert an array-like object into a true array. Doing that is surprisingly easy:</p>

<ol>
<li><p><strong>Use the <code>slice</code> method of arrays</strong></p>

<p>We can use the <a href="https://tc39.github.io/ecma262/#sec-array.prototype.slice" rel="noreferrer"><code>slice</code></a> method of arrays, which like the other methods mentioned above is "intentionally generic" and so can be used with array-like objects, like this:</p>

<pre><code>var trueArray = Array.prototype.slice.call(arrayLikeObject);
</code></pre>

<p>So for instance, if we want to convert a <code>NodeList</code> into a true array, we could do this:</p>

<pre><code>var divs = Array.prototype.slice.call(document.querySelectorAll("div"));
</code></pre>

<p>See the <em>Caveat for host-provided objects</em> below. In particular, note that this will fail in IE8 and earlier, which don't let you use host-provided objects as <code>this</code> like that.</p></li>
<li><p><strong>Use spread syntax (<code>...</code>)</strong></p>

<p>It's also possible to use ES2015's <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax" rel="noreferrer">spread syntax</a> with JavaScript engines that support this feature. Like <code>for-of</code>, this uses the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols" rel="noreferrer">iterator</a> provided by the object (see #4 in the previous section):</p>

<pre><code>var trueArray = [...iterableObject];
</code></pre>

<p>So for instance, if we want to convert a <code>NodeList</code> into a true array, with spread syntax this becomes quite succinct:</p>

<pre><code>var divs = [...document.querySelectorAll("div")];
</code></pre></li>
<li><p><strong>Use <code>Array.from</code></strong></p>

<p><code>Array.from</code> <a href="https://tc39.github.io/ecma262/#sec-array.from" rel="noreferrer">(spec)</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from" rel="noreferrer">(MDN)</a> (ES2015+, but easily polyfilled) creates an array from an array-like object, optionally passing the entries through a mapping function first. So:</p>

<pre><code>var divs = Array.from(document.querySelectorAll("div"));
</code></pre>

<p>Or if you wanted to get an array of the tag names of the elements with a given class, you'd use the mapping function:</p>

<pre><code>// Arrow function (ES2015):
var divs = Array.from(document.querySelectorAll(".some-class"), element =&gt; element.tagName);

// Standard function (since `Array.from` can be shimmed):
var divs = Array.from(document.querySelectorAll(".some-class"), function(element) {
    return element.tagName;
});
</code></pre></li>
</ol>

<h3>Caveat for host-provided objects</h3>

<p>If you use <code>Array.prototype</code> functions with <em>host-provided</em> array-like objects (DOM lists and other things provided by the browser rather than the JavaScript engine), you need to be sure to test in your target environments to make sure the host-provided object behaves properly. <strong>Most do behave properly</strong> (now), but it's important to test. The reason is that most of the <code>Array.prototype</code> methods you're likely to want to use rely on the host-provided object giving an honest answer to the abstract <a href="https://tc39.github.io/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots-hasproperty-p" rel="noreferrer"><code>[[HasProperty]]</code></a> operation. As of this writing, browsers do a very good job of this, but the 5.1 spec did allow for the possibility a host-provided object may not be honest. It's in <a href="http://www.ecma-international.org/ecma-262/5.1/#sec-8.6.2" rel="noreferrer">§8.6.2</a>, several paragraphs below the big table near the beginning of that section), where it says:</p>

<blockquote>
  <p>Host objects may implement these internal methods in any manner unless specified otherwise; for example, one possibility is that <code>[[Get]]</code> and <code>[[Put]]</code> for a particular host object indeed fetch and store property values but <code>[[HasProperty]]</code> always generates <strong>false</strong>.</p>
</blockquote>

<p>(I couldn't find the equivalent verbiage in the ES2015 spec, but it's bound to still be the case.) Again, as of this writing the common host-provided array-like objects in modern browsers [<code>NodeList</code> instances, for instance] <strong>do</strong> handle <code>[[HasProperty]]</code> correctly, but it's important to test.)</p>
</tr></td><tr><td><p><strong>Note</strong>: This answer is hopelessly out-of-date. For a more modern approach, look at <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array" rel="noreferrer">the methods available on an array</a>. Methods of interest might be:</p>

<ul>
<li>forEach</li>
<li>map</li>
<li>filter</li>
<li>zip</li>
<li>reduce</li>
<li>every</li>
<li>some</li>
</ul>

<hr>

<p>The standard way to iterate an array in <a href="http://en.wikipedia.org/wiki/JavaScript" rel="noreferrer">JavaScript</a> is a vanilla <code>for</code>-loop:</p>

<pre><code>var length = arr.length,
    element = null;
for (var i = 0; i &lt; length; i++) {
  element = arr[i];
  // Do something with element
}
</code></pre>

<p>Note, however, that this approach is only good if you have a dense array, and each index is occupied by an element. If the array is sparse, then you can run into performance problems with this approach, since you will iterate over a lot of indices that do not <em>really</em> exist in the array. In this case, a <code>for .. in</code>-loop might be a better idea. <strong>However</strong>, you must use the appropriate safeguards to ensure that only the desired properties of the array (that is, the array elements) are acted upon, since the <code>for..in</code>-loop will also be enumerated in legacy browsers, or if the additional properties are defined as <code>enumerable</code>.</p>

<p>In <a href="https://en.wikipedia.org/wiki/ECMAScript#ECMAScript.2C_5th_Edition" rel="noreferrer">ECMAScript 5</a> there will be a forEach method on the array prototype, but it is not supported in legacy browsers. So to be able to use it consistently you must either have an environment that supports it (for example, <a href="http://en.wikipedia.org/wiki/Node.js" rel="noreferrer">Node.js</a> for server side JavaScript), or use a "Polyfill". The Polyfill for this functionality is, however, trivial and since it makes the code easier to read, it is a good polyfill to include.</p>
</tr></td><tr><td><p>If you want to loop over an array, use the standard three-part <code>for</code> loop.</p>

<pre><code>for (var i = 0; i &lt; myArray.length; i++) {
    var arrayItem = myArray[i];
}
</code></pre>

<p>You can get some performance optimisations by caching <code>myArray.length</code> or iterating over it backwards.</p>
</tr></td><tr><td><p>There isn't any <code>for each</code> loop in native <a href="http://en.wikipedia.org/wiki/JavaScript" rel="noreferrer">JavaScript</a>. You can either use libraries to get this functionality (I recommend <a href="http://en.wikipedia.org/wiki/Underscore.js" rel="noreferrer">Underscore.js</a>), use a simple <code>for</code> in loop.</p>

<pre><code>for (var instance in objects) {
   ...
}
</code></pre>

<p>However, note that there may be reasons to use an even simpler <code>for</code> loop (see Stack Overflow question <em><a href="https://stackoverflow.com/questions/500504">Why is using “for…in” with array iteration such a bad idea?</a></em>)</p>

<pre><code>var instance;
for (var i=0; i &lt; objects.length; i++) {
    var instance = objects[i];
    ...
}
</code></pre>
</tr></td><tr><td><p>Some <a href="http://en.wikipedia.org/wiki/C_%28programming_language%29" rel="noreferrer">C</a>-style languages use <code>foreach</code> to loop through enumerations. In JavaScript this is done with the <a href="https://developer.mozilla.org/en/JavaScript/Reference/Statements/for...in" rel="noreferrer"><code>for..in</code> loop structure</a>:</p>

<pre><code>var index,
    value;
for (index in obj) {
    value = obj[index];
}
</code></pre>

<p>There is a catch. <code>for..in</code> will loop through each of the object's enumerable members, and the members on its prototype. To avoid reading values that are inherited through the object's prototype, simply check if the property belongs to the object:</p>

<pre><code>for (i in obj) {
    if (obj.hasOwnProperty(i)) {
        //do stuff
    }
}
</code></pre>

<p>Additionally, <a href="https://en.wikipedia.org/wiki/ECMAScript#ECMAScript.2C_5th_Edition" rel="noreferrer">ECMAScript 5</a> has added a <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/forEach" rel="noreferrer"><code>forEach</code></a> method to <code>Array.prototype</code> which can be used to enumerate over an array using a calback (the polyfill is in the docs so you can still use it for older browsers):</p>

<pre><code>arr.forEach(function (val, index, theArray) {
    //do stuff
});
</code></pre>

<p>It's important to note that <code>Array.prototype.forEach</code> doesn't break when the callback returns <code>false</code>. <a href="http://en.wikipedia.org/wiki/JQuery" rel="noreferrer">jQuery</a> and <a href="http://en.wikipedia.org/wiki/Underscore.js" rel="noreferrer">Underscore.js</a> provide their own variations on <code>each</code> to provide loops that can be short-circuited.</p>
</tr></td><tr><td><p>If you’re using the <a href="http://jquery.com/" rel="noreferrer"><strong>jQuery</strong></a> library, you can use <a href="http://api.jquery.com/jQuery.each/" rel="noreferrer"><strong>jQuery.each</strong></a>:</p>



<pre class="lang-js prettyprint-override"><code>$.each(yourArray, function(index, value) {
  // do your stuff here
});
</code></pre>

<p><strong>EDIT :</strong> </p>

<p>As per question, user want code in javascript instead of jquery so the edit is</p>

<pre class="lang-js prettyprint-override"><code>var length = yourArray.length;   
for (var i = 0; i &lt; length; i++) {
  // Do something with yourArray[i].
}
</code></pre>
</tr></td><tr><td><p>If you don't mind emptying the array:</p>

<pre><code>var x;

while(x = y.pop()){ 

    alert(x); //do something 

}
</code></pre>

<p><code>x</code> will contain the last value of <code>y</code> and it will be removed from the array. You can also use <code>shift()</code> which will give and remove the first item from <code>y</code>.</p>
</tr></td><tr><td><p>A <strong>forEach</strong> implementation (<a href="http://jsfiddle.net/nmoliveira/zNsyB/" rel="noreferrer">see in jsFiddle</a>):</p>

<pre><code>function forEach(list,callback) {
  var length = list.length;
  for (var n = 0; n &lt; length; n++) {
    callback.call(list[n]);
  }
}

var myArray = ['hello','world'];

forEach(
  myArray,
  function(){
    alert(this); // do something
  }
);
</code></pre>
</tr></td><tr><td><p>An easy solution now would be to use the <a href="https://en.wikipedia.org/wiki/Underscore.js">underscore.js library</a>. It's providing many useful tools, such as <code>each</code> and will automatically delegate the job to the native <code>forEach</code> if available.</p>

<p><a href="http://codepen.io/Micka33/pen/nbyxf">A CodePen example</a> of how it works is:</p>

<pre><code>var arr = ["elemA", "elemB", "elemC"];
_.each(arr, function(elem, index, ar)
{
...
});
</code></pre>

<h3>See also</h3>

<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach">Documentation for native <code>Array.prototype.forEach()</code></a>.</li>
<li>In <em><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for_each...in">for_each...in</a></em> (MDN) it is explained that <code>for each (variable in object)</code> is deprecated as the part of ECMA-357 (<a href="https://developer.mozilla.org/en-US/docs/E4X">EAX</a>) standard.</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of">for...of</a> (MDN) describes the next way of iterating using <code>for (variable of object)</code> as the part of the Harmony (ECMAScript&nbsp;6) proposal.</li>
</ul>
</tr></td><tr><td><p>There are three implementations of <code>foreach</code> in <a href="http://en.wikipedia.org/wiki/JQuery">jQuery</a> as follows.</p>

<pre><code>var a = [3,2];

$(a).each(function(){console.log(this.valueOf())}); //Method 1
$.each(a, function(){console.log(this.valueOf())}); //Method 2
$.each($(a), function(){console.log(this.valueOf())}); //Method 3
</code></pre>
</tr></td><tr><td><p>Probably the <code>for(i = 0; i &lt; array.length; i++)</code> loop is not the best choice. Why? If you have this:</p>

<pre><code>var array = new Array();
array[1] = "Hello";
array[7] = "World";
array[11] = "!";
</code></pre>

<p>The method will call from <code>array[0]</code> to <code>array[2]</code>. First, this will first reference variables you don't even have, second you would not have the variables in the array, and third this will make the code bolder. Look here, it's what I use:</p>

<pre><code>for(var i in array){
    var el = array[i];
    //If you want 'i' to be INT just put parseInt(i)
    //Do something with el
}
</code></pre>

<p>And if you want it to be a function, you can do this:</p>

<pre><code>function foreach(array, call){
    for(var i in array){
        call(array[i]);
    }
}
</code></pre>

<p>If you want to break, a little more logic:</p>

<pre><code>function foreach(array, call){
    for(var i in array){
        if(call(array[i]) == false){
            break;
        }
    }
}
</code></pre>

<p>Example:</p>

<pre><code>foreach(array, function(el){
    if(el != "!"){
        console.log(el);
    } else {
        console.log(el+"!!");
    }
});
</code></pre>

<p>It returns:</p>

<pre><code>//Hello
//World
//!!!
</code></pre>
</tr></td><tr><td><p>This is an iterator for NON-sparse list where the index starts at 0, which is the typical scenario when dealing with document.getElementsByTagName or document.querySelectorAll)</p>

<pre><code>function each( fn, data ) {

    if(typeof fn == 'string')
        eval('fn = function(data, i){' + fn + '}');

    for(var i=0, L=this.length; i &lt; L; i++) 
        fn.call( this[i], data, i );   

    return this;
}

Array.prototype.each = each;  
</code></pre>

<p><strong>Examples of usage:</strong></p>

<p><strong>Example #1</strong></p>

<pre><code>var arr = [];
[1, 2, 3].each( function(a){ a.push( this * this}, arr);
arr = [1, 4, 9]
</code></pre>

<p><strong>Example #2</strong></p>

<pre><code>each.call(document.getElementsByTagName('p'), "this.className = data;",'blue');
</code></pre>

<p>Each p tag gets <code>class="blue"</code></p>

<p><strong>Example #3</strong></p>

<pre><code>each.call(document.getElementsByTagName('p'), 
    "if( i % 2 == 0) this.className = data;",
    'red'
);
</code></pre>

<p>Every other p tag gets <code>class="red"</code>></p>

<p><strong>Example #4</strong></p>

<pre><code>each.call(document.querySelectorAll('p.blue'), 
    function(newClass, i) {
        if( i &lt; 20 )
            this.className = newClass;
    }, 'green'
);
</code></pre>

<p>And finally the first 20 blue p tags are changed to green</p>

<p>Caution when using string as function: the function is created out-of-context and ought to be used only where you are certain of variable scoping.  Otherwise, better to pass functions where scoping is more intuitive.</p>
</tr></td><tr><td><p>jQuery way using <code>$.map</code>:</p>

<pre><code>var data = [1, 2, 3, 4, 5, 6, 7];

var newData = $.map(data, function(element) {
    if (element % 2 == 0) {
        return element;
    }
});

// newData = [2, 4, 6];
</code></pre>
</tr></td><tr><td><p>ECMAScript&nbsp;5 (the version on JavaScript) to work with Arrays:</p>

<p><strong>forEach</strong> - Iterates through every item in the array and do whatever you need with each item.</p>

<pre><code>['C', 'D', 'E'].forEach(function(element, index) {
  console.log(element + " is #" + (index+1) + " in the musical scale");
});

// Output
// C is the #1 in musical scale
// D is the #2 in musical scale
// E is the #3 in musical scale
</code></pre>

<p>In case, more interested on operation on array using some inbuilt feature.</p>

<p><strong>map</strong> - It creates a new array with the result of the callback function. This method is good to be used when you need to format the elements of your array.</p>

<pre><code>// Let's upper case the items in the array
['bob', 'joe', 'jen'].map(function(elem) {
  return elem.toUpperCase();
});

// Output: ['BOB', 'JOE', 'JEN']
</code></pre>

<p><strong>reduce</strong> - As the name says, it reduces the array to a single value by calling the given function passing in the current element and the result of the previous execution.</p>

<pre><code>[1,2,3,4].reduce(function(previous, current) {
  return previous + current;
});
// Output: 10
// 1st iteration: previous=1, current=2 =&gt; result=3
// 2nd iteration: previous=3, current=3 =&gt; result=6
// 3rd iteration: previous=6, current=4 =&gt; result=10
</code></pre>

<p><strong>every</strong> - Returns true or false if all the elements in the array pass the test in the callback function.</p>

<pre><code>// Check if everybody has 18 years old of more.
var ages = [30, 43, 18, 5];
ages.every(function(elem) {
  return elem &gt;= 18;
});

// Output: false
</code></pre>

<p><strong>filter</strong> - Very similar to every except that filter returns an array with the elements that return true to the given function.</p>

<pre><code>// Finding the even numbers
[1,2,3,4,5,6].filter(function(elem){
  return (elem % 2 == 0)
});

// Output: [2,4,6]
</code></pre>
</tr></td><tr><td><p>I also would like to add this as a composition of a reverse loop and an answer above for someone that would like this syntax too.</p>

<pre><code>var foo = [object,object,object];
for (var i = foo.length, item; item = foo[--i];) {
    console.log(item);
}
</code></pre>

<p><strong>Pros:</strong></p>

<p>The benefit for this: You have the reference already in the first like that won't need to be declared later with another line. It is handy when looping trough the object array.</p>

<p><strong>Cons:</strong></p>

<p>This will break whenever the reference is false - falsey (undefined, etc.). It can be used as an advantage though. However, it would make it a little bit harder to read. And also depending on the browser it can be "not" optimized to work faster than the original one.</p>
</tr></td><tr><td><p>I know this is an old post, and there are so many great answers already. For a little more completeness I figured I'd throw in another one using <a href="https://angularjs.org/" rel="noreferrer">AngularJS</a>. Of course, this only applies if you're using Angular, obviously, nonetheless I'd like to put it anyway.</p>

<p><code>angular.forEach</code> takes 2 arguments and an optional third argument. The first argument is the object (array) to iterate over, the second argument is the iterator function, and the optional third argument is the object context (basically referred to inside the loop as 'this'.</p>

<p>There are different ways to use the forEach loop of angular. The simplest and probably most used is</p>

<pre><code>var temp = [1, 2, 3];
angular.forEach(temp, function(item) {
    //item will be each element in the array
    //do something
});
</code></pre>

<p>Another way that is useful for copying items from one array to another is</p>

<pre><code>var temp = [1, 2, 3];
var temp2 = [];
angular.forEach(temp, function(item) {
    this.push(item); //"this" refers to the array passed into the optional third parameter so, in this case, temp2.
}, temp2);
</code></pre>

<p>Though, you don't have to do that, you can simply do the following and it's equivalent to the previous example:</p>

<pre><code>angular.forEach(temp, function(item) {
    temp2.push(item);
});
</code></pre>

<p>Now there are pros and cons of using the <code>angular.forEach</code> function as opposed to the built in vanilla-flavored <code>for</code> loop.</p>

<p><strong>Pros</strong></p>

<ul>
<li>Easy readability</li>
<li>Easy writability</li>
<li>If available, <code>angular.forEach</code> will use the ES5 forEach loop. Now, I will get to efficientcy in the cons section, as the forEach loops are <em>much</em> slower than the for loops. I mention this as a pro because it's nice to be consistent and standardized.</li>
</ul>

<p>Consider the following 2 nested loops, which do exactly the same thing. Let's say that we have 2 arrays of objects and each object contains an array of results, each of which has a Value property that's a string (or whatever). And let's say we need to iterate over each of the results and if they're equal then perform some action: </p>

<pre><code>angular.forEach(obj1.results, function(result1) {
    angular.forEach(obj2.results, function(result2) {
        if (result1.Value === result2.Value) {
            //do something
        }
    });
});

//exact same with a for loop
for (var i = 0; i &lt; obj1.results.length; i++) {
    for (var j = 0; j &lt; obj2.results.length; j++) {
        if (obj1.results[i].Value === obj2.results[j].Value) {
            //do something
        }
    }
}
</code></pre>

<p>Granted this is a very simple hypothetical example, but I've written triple embedded for loops using the second approach and it was <em>very</em> hard to read, and write for that matter.</p>

<p><strong>Cons</strong></p>

<ul>
<li>Efficiency. <code>angular.forEach</code>, and the native <code>forEach</code>, for that matter, are both <em>so much</em> slower than the normal <code>for</code> loop....about <a href="http://jsperf.com/angular-foreach-vs-native-for-loop/3" rel="noreferrer">90% slower</a>. So for large data sets, best to stick to the native <code>for</code> loop.</li>
<li>No break, continue, or return support. <code>continue</code> is actually supported by "<a href="https://github.com/angular/angular.js/issues/263" rel="noreferrer">accident</a>", to continue in an <code>angular.forEach</code> you simple put a <code>return;</code> statement in the function like <code>angular.forEach(array, function(item) { if (someConditionIsTrue) return; });</code> which will cause it to continue out of the function for that iteration. This is also due to the fact that the native <code>forEach</code> does not support break or continue either.</li>
</ul>

<p>I'm sure there's various other pros and cons as well, and please feel free to add any that you see fit. I feel that, bottom line, if you need efficiency, stick with just the native <code>for</code> loop for your looping needs. But, if your datasets are smaller and a some efficiency is okay to give up in exchange for readability and writability, then by all means throw an <code>angular.forEach</code> in that bad boy.</p>
</tr></td><tr><td><h1>Loop backwards</h1>

<p>I think the <em>reverse</em> for loop deserves a mention here:</p>

<pre><code>for (var i = array.length; i--; ) {
     // process array[i]
}
</code></pre>

<h2>Advantages:</h2>

<ul>
<li>You do not need to declare a temporary <code>len</code> variable, or compare against <code>array.length</code> on each iteration, either of which might be a minute optimisation.</li>
<li><strong>Removing siblings</strong> from the DOM in reverse order is usually <strong>more efficient</strong>.  (The browser needs to do less shifting of elements in its internal arrays.)</li>
<li>If you <strong>modify the array</strong> while looping, at or after index <em>i</em> (for example you remove or insert an item at <code>array[i]</code>), then a forward loop would skip the item that shifted left into position <em>i</em>, or re-process the <em>i</em>th item that was shifted right.  In a traditional for loop, you <em>could</em> update <em>i</em> to point to the next item that needs processing - 1, but simply reversing the direction of iteration is often a <strong>simpler</strong> and <a href="https://stackoverflow.com/questions/23186254/javascript-splice-changing-earlier-values-in-an-array/23186450#23186450">more elegant solution</a>.</li>
<li>Similarly, when modifying or removing <strong>nested</strong> DOM elements, processing in reverse can <strong>circumvent errors</strong>. For example, consider modifying the innerHTML of a parent node before handling its children.  By the time the child node is reached it will be detached from the DOM, having been replaced by a newly created child when the parent's innerHTML was written.</li>
<li>It is <strong>shorter</strong> to type, and <strong>read</strong>, than some of the other options available.  Although it loses to <code>forEach()</code> and to ES6's <code>for ... of</code>.</li>
</ul>

<h2>Disadvantages:</h2>

<ul>
<li>It processes the items in reverse order.  If you were building a new array from the results, or printing things on screen, naturally <strong>the output will be reversed</strong> with respect to the original order.</li>
<li>Repeatedly inserting siblings into the DOM as a first child in order to retain their order is <strong>less efficient</strong>.  (The browser would keep having to shift things right.)  To create DOM nodes efficiently and in order, just loop forwards and append as normal (and also use a "document fragment").</li>
<li>The reverse loop is <strong>confusing</strong> to junior developers.  (You may consider that an advantage, depending on your outlook.)</li>
</ul>

<hr>

<h2>Should I always use it?</h2>

<p>Some developers use the reverse for loop <em>by default</em>, unless there is a good reason to loop forwards.</p>

<p>Although the performance gains are usually insignificant, it sort of screams:</p>

<blockquote>
  <p>"Just do this to every item in the list, I don't care about the order!"</p>
</blockquote>

<p>However in practice that is <strong>not</strong> actually a reliable indication of intent, since it is indistinguishable from those occasions when you <strong><em>do</em></strong> care about the order, and really do <strong><em>need</em></strong> to loop in reverse.  So in fact another construct would be needed to accurately express the "don't care" intent, something currently unavailable in most languages, including ECMAScript, but which could be called, for example, <code>forEachUnordered()</code>.</p>

<p>If order doesn't matter, and <strong>efficiency</strong> is a concern (in the innermost loop of a game or animation engine), then it may be acceptable to use the reverse for loop as your go-to pattern.  Just remember that seeing a reverse for loop in existing code <strong>does not necessarily mean</strong> that the order irrelevant!</p>

<h3>It was better to use forEach()</h3>

<p>In general for higher level code where <strong>clarity and safety</strong> are greater concerns, I previously recommended using <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach" rel="noreferrer"><code>Array::forEach</code></a> as your default pattern for looping (although these days I prefer to use <code>for..of</code>).  Reasons to prefer <code>forEach</code> over a reverse loop are:</p>

<ul>
<li>It is clearer to read.</li>
<li>It indicates that <em>i</em> is not going to be shifted within the block (which is always a possible surprise hiding in long <code>for</code> and <code>while</code> loops).</li>
<li>It gives you a free scope for closures.</li>
<li>It reduces leakage of local variables and accidental collision with (and mutation of) outer variables.</li>
</ul>

<p>Then when you do see the reverse for loop in your code, that is a hint that it is reversed for a good reason (perhaps one of the reasons described above).  And seeing a traditional forward for loop may indicate that shifting can take place.</p>

<p>(If the discussion of intent makes no sense to you, then you and your code may benefit from watching Crockford's lecture on <a href="https://www.youtube.com/watch?v=taaEzHI9xyY&amp;t=480" rel="noreferrer">Programming Style &amp; Your Brain</a>.)</p>

<h3>It is now even better to use for..of!</h3>

<p>There is a debate about whether <code>for..of</code> or <code>forEach()</code> are preferable:</p>

<ul>
<li><p>For maximum browser support, <code>for..of</code> <a href="https://github.com/airbnb/javascript/issues/1122#issuecomment-471169142" rel="noreferrer">requires a polyfill</a> for iterators, making your app slightly slower to execute and slightly larger to download.</p></li>
<li><p>For that reason (and to encourage use of <code>map</code> and <code>filter</code>), <a href="https://github.com/airbnb/javascript#iterators-and-generators" rel="noreferrer">some front-end style guides</a> ban <code>for..of</code> completely!</p></li>
<li><p>But the above concerns is not applicable to Node.js applications, where <code>for..of</code> is now well supported.</p></li>
<li><p>And furthermore <code>await</code> <a href="https://gist.github.com/joeytwiddle/37d2085425c049629b80956d3c618971" rel="noreferrer">does not work</a> inside <code>forEach()</code>.  Using <code>for..of</code> is <a href="https://github.com/airbnb/javascript/issues/1122#issuecomment-259876436" rel="noreferrer">the clearest pattern</a> in this case.</p></li>
</ul>

<p>Personally, I tend to use whatever looks easiest to read, unless performance or minification has become a major concern.  So these days I prefer to use <code>for..of</code> instead of <code>forEach()</code>, but I will always use <code>map</code> or <code>filter</code> or <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find" rel="noreferrer"><code>find</code></a> or <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some" rel="noreferrer"><code>some</code></a> when applicable. 
 (For the sake of my colleagues, I rarely use <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce" rel="noreferrer"><code>reduce</code></a>.)</p>

<hr>

<h2>How does it work?</h2>

<pre><code>for (var i = 0; i &lt; array.length; i++) { ... }   // Forwards

for (var i = array.length; i--; )    { ... }   // Reverse
</code></pre>

<p>You will notice that <code>i--</code> is the middle clause (where we usually see a comparison) and the last clause is empty (where we usually see <code>i++</code>).  That means that <code>i--</code> is also used as the <em>condition</em> for continuation.  Crucially, it is executed and checked <em>before</em> each iteration.</p>

<ul>
<li><p><strong>How can it start at <code>array.length</code> without exploding?</strong></p>

<p>Because <code>i--</code> runs <em>before</em> each iteration, on the first iteration we will actually be accessing the item at <code>array.length - 1</code> which avoids any issues with <strike>Array-out-of-bounds</strike> <code>undefined</code> items.</p></li>
<li><p><strong>Why doesn't it stop iterating before index 0?</strong></p>

<p>The loop will stop iterating when the condition <code>i--</code> evaluates to a falsey value (when it yields 0).</p>

<p>The trick is that unlike <code>--i</code>, the trailing <code>i--</code> operator decrements <code>i</code> but yields the value <strong><em>before</em></strong> the decrement.  Your console can demonstrate this:</p>

<p><code>&gt; var i = 5; [i, i--, i];</code></p>

<p><code>[5, 5, 4]</code></p>

<p>So on the final iteration, <em>i</em> was previously <strong>1</strong> and the <code>i--</code> expression changes it to <strong>0</strong> but actually yields <strong>1</strong> (truthy), and so the condition passes.  On the next iteration <code>i--</code> changes <em>i</em> to <strong>-1</strong> but yields <strong>0</strong> (falsey), causing execution to immediately drop out of the bottom of the loop.</p>

<p>In the traditional forwards for loop, <code>i++</code> and <code>++i</code> are interchangeable (as Douglas Crockford points out).  However in the reverse for loop, because our decrement is also our condition expression, we must stick with <code>i--</code> if we want to process the item at index 0.</p></li>
</ul>

<hr>

<h2>Trivia</h2>

<p>Some people like to draw a little arrow in the reverse <code>for</code> loop, and end with a wink:</p>

<pre><code>for (var i = array.length; i --&gt; 0 ;) {
</code></pre>

<hr>

<p><em>Credits go to WYL for showing me the benefits and horrors of the reverse for loop.</em></p>
</tr></td><tr><td><p>There's no inbuilt ability to break in <code>forEach</code>. To interrupt execution use the <code>Array#some</code> like below:</p>

<pre><code>[1,2,3].some(function(number) {
    return number === 1;
});
</code></pre>

<p>This works because <code>some</code> returns true as soon as any of the callbacks, executed in array order, returns true, short-circuiting the execution of the rest. 
<a href="https://stackoverflow.com/questions/2641347/how-to-short-circuit-array-foreach-like-calling-break">Original Answer</a>
see Array prototype for <a href="http://www.ecma-international.org/ecma-262/5.1/#sec-15.4.4.17" rel="noreferrer">some</a></p>
</tr></td><tr><td><p><strong>As of ECMAScript&nbsp;6:</strong></p>

<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>list = [0, 1, 2, 3]
for (let obj of list) {
    console.log(obj)
}</code></pre>
</div>
</div>
</p>

<p>Where <code>of</code> avoids the oddities associated with <code>in</code> and makes it work like the <code>for</code> loop of any other language, and <code>let</code> binds <code>i</code> within the loop as opposed to within the function.</p>

<p>The braces (<code>{}</code>) can be omitted when there is only one command (e.g. in the example above).</p>
</tr></td><tr><td><p>There are <strong>a few ways</strong> to loop through an array in JavaScript, as below:</p>

<p><strong>for</strong> - it's <strong>the most common one</strong>. Full block of code for looping <br/></p>

<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>var languages = ["Java", "JavaScript", "C#", "Python"];
var i, len, text;
for (i = 0, len = languages.length, text = ""; i &lt; len; i++) {
    text += languages[i] + "&lt;br&gt;";
}
document.getElementById("example").innerHTML = text;</code></pre>
<pre class="snippet-code-html lang-html prettyprint-override"><code>&lt;p id="example"&gt;&lt;/p&gt;</code></pre>
</div>
</div>
</p>

<p><strong>while</strong> - loop while a condition is through. It seems to be the fastest loop <br/></p>

<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>var text = "";
var i = 0;
while (i &lt; 10) {
    text +=  i + ") something&lt;br&gt;";
    i++;
}
document.getElementById("example").innerHTML = text;</code></pre>
<pre class="snippet-code-html lang-html prettyprint-override"><code>&lt;p id="example"&gt;&lt;/p&gt;</code></pre>
</div>
</div>
</p>

<p><strong>do/while</strong> - also loop through a block of code while the condition is true, will run at least one time <br/></p>

<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>var text = ""
var i = 0;

do {
    text += i + ") something &lt;br&gt;";
    i++;
}
while (i &lt; 10);

document.getElementById("example").innerHTML = text;</code></pre>
<pre class="snippet-code-html lang-html prettyprint-override"><code>&lt;p id="example"&gt;&lt;/p&gt;</code></pre>
</div>
</div>
</p>

<p><strong>Functional loops</strong> - <code>forEach</code>, <code>map</code>, <code>filter</code>, also <code>reduce</code> (they loop through the function, but they are used if you need to do something with your array, etc.</p>

<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>// For example, in this case we loop through the number and double them up using the map function
var numbers = [65, 44, 12, 4];
document.getElementById("example").innerHTML = numbers.map(function(num){return num * 2});</code></pre>
<pre class="snippet-code-html lang-html prettyprint-override"><code>&lt;p id="example"&gt;&lt;/p&gt;</code></pre>
</div>
</div>
</p>

<p>For more information and examples about functional programming on arrays, look at the blog post <em><a href="http://cryto.net/~joepie91/blog/2015/05/04/functional-programming-in-javascript-map-filter-reduce/" rel="nofollow noreferrer">Functional programming in JavaScript: map, filter and reduce</a></em>.</p>
</tr></td><tr><td><p>The lambda syntax doesn't usually work in Internet&nbsp;Explorer&nbsp;10  or below.</p>

<p>I usually use the</p>

<pre><code>[].forEach.call(arrayName,function(value,index){
    console.log("value of the looped element" + value);
    console.log("index of the looped element" + index);
});
</code></pre>

<p>If you are a jQuery <em>fan</em> and already have a jQuery file running, you should reverse the positions of the index and value parameters</p>

<pre><code>$("#ul&gt;li").each(function(**index, value**){
    console.log("value of the looped element" + value);
    console.log("index of the looped element" + index);
});
</code></pre>
</tr></td><tr><td><p>A way closest to your idea would be to use <code>Array.forEach()</code> which accepts a closure function which will be executed for each element of the array.</p>

<pre><code>myArray.forEach(
  (item) =&gt; {
    // Do something
    console.log(item);
  }
);
</code></pre>

<p>Another viable way would be to use <code>Array.map()</code> which works in the same way, but it also takes all values that you return and returns them in a new array (essentially mapping each element to a new one), like this:</p>

<pre><code>var myArray = [1, 2, 3];
myArray = myArray.map(
  (item) =&gt; {
    return item + 1;
  }
);

console.log(myArray); // [2, 3, 4]
</code></pre>
</tr></td><tr><td><pre><code>var a = ["car", "bus", "truck"]
a.forEach(function(item, index) {
    console.log("Index" + index);
    console.log("Element" + item);
})
</code></pre>
</tr></td><tr><td><p>You can call forEach like this:</p>

<p><code>forEach</code> will iterate over the array you provide and for each iteration it will have <code>element</code> which holds the value of that iteration. If you need index you can get the current index by passing the <code>i</code> as the second parameter in the callback function for forEach. </p>

<p>Foreach is basically a High Order Function, Which takes another function as its parameter. </p>

<pre><code>let theArray= [1,3,2];

theArray.forEach((element) =&gt; {
  // Use the element of the array
  console.log(element)
}
</code></pre>

<p>Output:</p>

<pre><code>1
3
2
</code></pre>

<p>You can also iterate over an array like this:</p>

<pre><code>for (let i=0; i&lt;theArray.length; i++) {
  console.log(i); // i will have the value of each index
}
</code></pre>
</tr></td><tr><td><p>If you have a massive array you should use <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators" rel="noreferrer"><strong><code>iterators</code></strong></a> to gain some efficiency. Iterators are a property of certain JavaScript collections (like <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map" rel="noreferrer"><code>Map</code></a>, <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Set" rel="noreferrer"><code>Set</code></a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String" rel="noreferrer"><code>String</code></a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array" rel="noreferrer"><code>Array</code></a>). Even, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of" rel="noreferrer"><strong><code>for..of</code></strong></a> uses <strong><code>iterator</code></strong> under-the-hood.</p>

<p>Iterators improve efficiency by letting you consume the items in a list one at a time as if they were a stream. What makes an iterator special is how it traverses a collection. Other loops need to load the entire collection up front in order to iterate over it, whereas an iterator only needs to know the current position in the collection.             </p>

<p>You access the current item by calling the iterator’s <code>next</code> method. The next method will return the <strong><code>value</code></strong> of the current item and a <strong><code>boolean</code></strong> to indicate when you have reached the end of the collection. The following is an example of creating an iterator from an array.               </p>

<p>Transform your regular array to iterator using <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/values" rel="noreferrer"><code>values()</code></a> method like this:               </p>

<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>    const myArr = [2,3,4]

let it = myArr.values();

console.log(it.next());
console.log(it.next());
console.log(it.next());
console.log(it.next());</code></pre>
</div>
</div>
</p>

<p>You can also transform your regular array to iterator using <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/iterator" rel="noreferrer"><code>Symbol.iterator</code></a> like this:         </p>

<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>const myArr = [2,3,4]

let it = myArr[Symbol.iterator]();

console.log(it.next());
console.log(it.next());
console.log(it.next());
console.log(it.next());</code></pre>
</div>
</div>
</p>

<p>You can also transform your regular <code>array</code> to an <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators" rel="noreferrer"><code>iterator</code></a> like this:          </p>

<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>let myArr = [8, 10, 12];

function makeIterator(array) {
    var nextIndex = 0;
    
    return {
       next: function() {
           return nextIndex &lt; array.length ?
               {value: array[nextIndex++], done: false} :
               {done: true};
       }
    };
};

var it = makeIterator(myArr);

console.log(it.next().value);   // {value: 8, done: false}
console.log(it.next().value);   // {value: 10, done: false}
console.log(it.next().value);   // {value: 12, done: false}
console.log(it.next().value);   // {value: undefined, done: true}</code></pre>
</div>
</div>
</p>

<p><strong>NOTE</strong>:                </p>

<ul>
<li>Iterators are exhaustible in nature. </li>
<li>Objects are not <code>iterable</code> by default. Use <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in" rel="noreferrer"><code>for..in</code></a> in that case because instead of values it works with keys.</li>
</ul>

<p>You can read more about <code>iteration protocol</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols" rel="noreferrer">here</a>.  </p>
</tr></td><tr><td><p>If you want to use <code>forEach()</code>, it will look like - </p>

<pre><code>theArray.forEach ( element =&gt; {
    console.log(element);
});
</code></pre>

<p>If you want to use <code>for()</code>, it will look like -   </p>

<pre><code>for(let idx = 0; idx &lt; theArray.length; idx++){
    let element = theArray[idx];
    console.log(element);
}
</code></pre>
</tr></td><tr><td><p><strong>Using loops with ECMAScript 6  <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment" rel="noreferrer">destructuring</a> and the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax" rel="noreferrer">spread operator</a></strong></p>
<p>Destructuring and using of the spread operator have proven quite useful for newcomers to ECMAScript 6 as being more human-readable/aesthetic, although some JavaScript veterans might consider it messy. Juniors or some other people might find it useful.</p>
<blockquote>
<p>The following examples will use the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of" rel="noreferrer"><code>for...of</code></a> statement and the <a href="https://developer.mozilla.org/ro/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach" rel="noreferrer"><code>.forEach</code></a> method.</p>
<p><strong>Examples 6, 7, and 8</strong> can be used with any functional loops like <code>.map</code>, <code>.filter</code>, <code>.reduce</code>, <code>.sort</code>, <code>.every</code>, <code>.some</code>. For more information about these methods, check out the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array" rel="noreferrer">Array Object</a>.</p>
</blockquote>
<p><strong>Example 1:</strong> Normal <code>for...of</code> loop - no tricks here.</p>
<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>let arrSimple = ['a', 'b', 'c'];

for (let letter of arrSimple) {
  console.log(letter);
}</code></pre>
</div>
</div>
</p>
<p><strong>Example 2:</strong> Split words to characters</p>
<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>let arrFruits = ['apple', 'orange', 'banana'];

for (let [firstLetter, ...restOfTheWord] of arrFruits) {
  // Create a shallow copy using the spread operator
  let [lastLetter] = [...restOfTheWord].reverse();
  console.log(firstLetter, lastLetter, restOfTheWord);
}</code></pre>
</div>
</div>
</p>
<p><strong>Example 3:</strong> Looping with a <code>key</code> and <code>value</code></p>
<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>// let arrSimple = ['a', 'b', 'c'];

// Instead of keeping an index in `i` as per example `for(let i = 0 ; i&lt;arrSimple.length;i++)`
// this example will use a multi-dimensional array of the following format type:
// `arrWithIndex: [number, string][]`

let arrWithIndex = [
  [0, 'a'],
  [1, 'b'],
  [2, 'c'],
];

// Same thing can be achieved using `.map` method
// let arrWithIndex = arrSimple.map((i, idx) =&gt; [idx, i]);

// Same thing can be achieved using `Object.entries`
// NOTE: `Object.entries` method doesn't work on Internet Explorer  unless it's polyfilled
// let arrWithIndex = Object.entries(arrSimple);

for (let [key, value] of arrWithIndex) {
  console.log(key, value);
}</code></pre>
</div>
</div>
</p>
<p><strong>Example 4:</strong> Get object properties inline</p>
<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>let arrWithObjects = [{
    name: 'Jon',
    age: 32
  },
  {
    name: 'Elise',
    age: 33
  }
];

for (let { name, age: aliasForAge } of arrWithObjects) {
  console.log(name, aliasForAge);
}</code></pre>
</div>
</div>
</p>
<p><strong>Example 5:</strong> Get deep object properties of what you need</p>
<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>let arrWithObjectsWithArr = [{
    name: 'Jon',
    age: 32,
    tags: ['driver', 'chef', 'jogger']
  },
  {
    name: 'Elise',
    age: 33,
    tags: ['best chef', 'singer', 'dancer']
  }
];

for (let { name, tags: [firstItemFromTags, ...restOfTags] } of arrWithObjectsWithArr) {
  console.log(name, firstItemFromTags, restOfTags);
}</code></pre>
</div>
</div>
</p>
<p><strong>Example 6:</strong> Is <strong>Example 3</strong> used with <code>.forEach</code></p>
<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>let arrWithIndex = [
  [0, 'a'],
  [1, 'b'],
  [2, 'c'],
];

// Not to be confused here, `forEachIndex` is the real index
// `mappedIndex` was created by "another user", so you can't really trust it

arrWithIndex.forEach(([mappedIndex, item], forEachIndex) =&gt; {
  console.log(forEachIndex, mappedIndex, item);
});</code></pre>
</div>
</div>
</p>
<p><strong>Example 7:</strong> Is <strong>Example 4</strong> used with <code>.forEach</code></p>
<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>let arrWithObjects = [{
    name: 'Jon',
    age: 32
  },
  {
    name: 'Elise',
    age: 33
  }
];
// NOTE: Destructuring objects while using shorthand functions
// are required to be surrounded by parentheses
arrWithObjects.forEach( ({ name, age: aliasForAge }) =&gt; {
  console.log(name, aliasForAge)
});</code></pre>
</div>
</div>
</p>
<p><strong>Example 8:</strong> Is <strong>Example 5</strong> used with <code>.forEach</code></p>
<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>let arrWithObjectsWithArr = [{
    name: 'Jon',
    age: 32,
    tags: ['driver', 'chef', 'jogger']
  },
  {
    name: 'Elise',
    age: 33,
    tags: ['best chef', 'singer', 'dancer']
  }
];

arrWithObjectsWithArr.forEach(({
  name,
  tags: [firstItemFromTags, ...restOfTags]
}) =&gt; {
  console.log(name, firstItemFromTags, restOfTags);
});</code></pre>
</div>
</div>
</p>
</tr></td><tr><td><h2>Summary:</h2>

<p>When iterating over an array, we often want to accomplish one of the following goals:</p>

<ol>
<li><p>We want to iterate over the array and create a new array:</p>

<p><code>Array.prototype.map</code> <br><br></p></li>
<li><p>We want to iterate over the array and don't create a new array:</p>

<p><code>Array.prototype.forEach</code> <br><br>
<code>for..of</code> <strong>loop</strong></p></li>
</ol>

<p>In JavaScript, there are many ways of accomplishing both of these goals. However, some are more convenient than others. Below you can find some commonly used methods (the most convenient IMO) to accomplish array iteration in JavaScript.</p>

<h2>Creating new array: <code>Map</code></h2>

<p><code>map()</code> is a function located on <code>Array.prototype</code> which can transform every element of an array and then returns a <strong>new</strong> array. <code>map()</code> takes as an argument a callback function and works in the following manner:</p>

<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>let arr = [1, 2, 3, 4, 5];

let newArr = arr.map((element, index, array) =&gt; {
  return element * 2;
})

console.log(arr);
console.log(newArr);</code></pre>
</div>
</div>
</p>

<p>The callback which we have passed into <code>map()</code> as an argument gets executed for every element. Then an array gets returned which has the same length as the original array. In this new array element is transformed by the callback function passed in as an argument to <code>map()</code>.</p>

<p>The distinct difference between <code>map</code> and another loop mechanism like <code>forEach</code> and a <code>for..of</code> loop is that <strong><code>map</code> returns a new array and leaves the old array intact</strong> (except if you explicitly manipulate it with thinks like <code>splice</code>).</p>

<p>Also, note that the <code>map</code> function's callback provides the index number of the current iteration as a second argument. Furthermore, does the third argument provide the array on which <code>map</code> was called? Sometimes these properties can be very useful.</p>

<h2>Loop using <code>forEach</code></h2>

<p><code>forEach</code> is a function which is located on <code>Array.prototype</code> which takes a callback function as an argument. It then executes this callback function for every element in the array. In contrast to the <code>map()</code> function, the forEach function returns nothing (<code>undefined</code>). For example:</p>

<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>let arr = [1, 2, 3, 4, 5];

arr.forEach((element, index, array) =&gt; {

  console.log(element * 2);

  if (index === 4) {
    console.log(array)
  }
  // index, and oldArray are provided as 2nd and 3th argument by the callback

})

console.log(arr);</code></pre>
</div>
</div>
</p>

<p>Just like the <code>map</code> function, the <code>forEach</code> callback provides the index number of the current iteration as a second argument. Also, does the third argument provide the array on which <code>forEach</code> was called?</p>

<h2>Loop through elements using <code>for..of</code></h2>

<p>The <code>for..of</code> loop loops through every element of an array (or any other iterable object). It works in the following manner:</p>

<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>let arr = [1, 2, 3, 4, 5];

for(let element of arr) {
  console.log(element * 2);
}</code></pre>
</div>
</div>
</p>

<p>In the above example, <code>element</code> stands for an array element and <code>arr</code> is the array which we want to loop. Note that the name <code>element</code> is arbitrary, and we could have picked any other name like 'el' or something more declarative when this is applicable.</p>

<p>Don't confuse the <code>for..in</code> loop with the <code>for..of</code> loop. <code>for..in</code> will loop through all enumerable properties of the array whereas the <code>for..of</code> loop will only loop through the array elements. For example:</p>

<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>let arr = [1, 2, 3, 4, 5];

arr.foo = 'foo';

for(let element of arr) {
  console.log(element);
}

for(let element in arr) {
  console.log(element);
}</code></pre>
</div>
</div>
</p>
</tr></td><tr><td><p>I come from Python, and I found this way much clearer.</p>

<p>theArray being the array, and <code>instance</code> being the elements of the array:</p>

<pre><code>for (let instance of theArray)
{
    console.log("The instance", instance);
}
</code></pre>

<p>or</p>

<pre><code>for (instance in theArray)
{
    console.log("The instance", instance);
}
</code></pre>

<p>compare to:</p>

<pre><code>theArray.forEach(function(instance) {
    console.log(instance);
});
</code></pre>

<p>But at the end of the day both are doing the same thing.</p>
</tr></td><tr><td><p>If you want to keep your code in the functional way, use <code>map</code>:</p>

<pre><code>theArray.map(instance =&gt; do_something);
</code></pre>

<p>In this way you will generate a new array to future operation and will skip any not desirable side effect.</p>
</tr></td><tr><td><p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>// Looping through arrays using the foreach ECMAScript 6 way

var data = new Array(1, 2, 3, 4, 5);
data.forEach((val,index) =&gt; {
    console.log("index: ", index); // Index
    console.log("value: ", val); // Value
});</code></pre>
</div>
</div>
</p>
</tr></td><tr><td><p>If you want to loop through an array of objects with the arrow function:</p>

<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>let arr = [{name:'john', age:50}, {name:'clark', age:19}, {name:'mohan', age:26}];

arr.forEach((person)=&gt;{
  console.log('I am ' + person.name + ' and I am ' + person.age + ' old');
})</code></pre>
</div>
</div>
</p>
</tr></td><tr><td><p>You can use the forEach() API (provided by JavaScript) which accepts a function as a callback and runs one time for each element present inside the array.</p>

<p>See <em><a href="https://fullstackgeek.blogspot.com/2019/01/arrays-in-javascript-part-2.html" rel="nofollow noreferrer">Arrays in JavaScript: Part 2</a></em>.</p>
</tr></td><tr><td><p>I'd argue that <code>for/of</code> is the way to go:</p>

<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>const arr = ['a', 'b', 'c'];

for (const v of arr) {
  console.log(v); // Prints "a", "b", "c"
}</code></pre>
</div>
</div>
</p>

<ul>
<li><p>Unlike <code>for/in</code>, <code>for/of</code> skips non-numeric properties on the array. For example, if you set <code>arr.foo = 'test'</code>, <code>for (var v in arr)</code> will loop through the <code>'foo'</code> key.</p></li>
<li><p>Unlike <code>forEach()</code>, <code>for/of</code> doesn't skip "holes" in arrays. <code>const arr = ['a',, 'c']</code> is valid JavaScript, just the 2nd element is a "hole". The array is functionally equivalent to <code>['a', undefined, 'c']</code>.</p></li>
</ul>

<p>You can read more in <a href="https://thecodebarbarian.com/for-vs-for-each-vs-for-in-vs-for-of-in-javascript" rel="nofollow noreferrer">this blog post on <code>for/of</code> vs <code>forEach()</code>.</a></p>
</tr></td><tr><td><p><a href="https://developer.mozilla.org/id/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach" rel="nofollow noreferrer">Mozilla documentation</a></p>

<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>/* Get all forms */
document.querySelectorAll( "form" ).forEach( form =&gt; {

  /* For each form, add the onsubmit event */
  form.addEventListener( "submit", event =&gt; {
    event.preventDefault(); // Return false

    /* Display it */
    alert(event.target.action);
    console.log(event.target);
  } );

} );</code></pre>
<pre class="snippet-code-html lang-html prettyprint-override"><code>&lt;form action="form1.php" &gt;
  &lt;input type="submit" value="Submit" /&gt;
&lt;/form&gt;
&lt;form action="form2.php" &gt;
  &lt;input type="submit" value="Submit" /&gt;
&lt;/form&gt;
&lt;form action="form3.php" &gt;
  &lt;input type="submit" value="Submit" /&gt;
&lt;/form&gt;</code></pre>
</div>
</div>
</p>
</tr></td><tr><td><h2>Performance</h2>

<p>Today (2019-12-18) I perform test on my <a href="https://en.wikipedia.org/wiki/MacOS_High_Sierra" rel="nofollow noreferrer">macOS v10.13.6</a> (High Sierra), on Chrome v 79.0, Safari v13.0.4 and Firefox v71.0 (64 bit) - conclusions about optimisation (and <em><a href="https://stackoverflow.com/questions/3470990/is-micro-optimization-worth-the-time/3471000#3471000">micro-optimisation</a></em> which usually is not worth to introduce it to code because the benefit is small, but code complexity grows).</p>

<ul>
<li><p>It looks like the traditional <code>for i</code> (<strong>Aa</strong>) is a good choice to write fast code on all browsers.</p></li>
<li><p>The other solutions, like <code>for-of</code> (<strong>Ad</strong>), all in group <strong>C.</strong>... are usually 2 - 10 (and more) times slower than <strong>Aa</strong>, but for small arrays it is ok to use it - for the sake of increase code clarity.</p></li>
<li><p>The loops with array length cached in <code>n</code> (<strong>Ab, Bb, Be</strong>) are sometimes faster, sometimes not. Probably compilers automatically detect this situation and introduce caching. The speed differences between the cached and no-cached versions (<strong>Aa, Ba, Bd</strong>) are about ~1%, so it looks like introduce <code>n</code> is a <em><a href="https://stackoverflow.com/questions/3470990/is-micro-optimization-worth-the-time/3471000#3471000">micro-optimisation</a></em>.</p></li>
<li><p>The <code>i--</code> like solutions where the loop starts from the last array element (<strong>Ac, Bc</strong>) are usually ~30% slower than forward solutions - probably the reason is the way of <a href="https://stackoverflow.com/questions/1950878/c-for-loop-indexing-is-forward-indexing-faster-in-new-cpus">CPU memory cache working</a> - forward memory reading is more optimal for CPU caching). <strong>Is recommended to NOT USE such solutions.</strong></p></li>
</ul>

<h2>Details</h2>

<p>In tests we calculate the sum of array elements. I perform a test for small arrays (10 elements) and big arrays (1M elements) and divide them into three groups:</p>

<ul>
<li><strong>A</strong> - <code>for</code> tests</li>
<li><strong>B</strong> - <code>while</code> tests</li>
<li><strong>C</strong> - other/alternative methods</li>
</ul>

<p><div class="snippet" data-lang="js" data-hide="true" data-console="true" data-babel="false">
<div class="snippet-code snippet-currently-hidden">
<pre class="snippet-code-js lang-js prettyprint-override"><code>let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
//let arr = Array.from(Array(1000000), (x, i) =&gt; i%10);

function Aa(a, s=0) {
  for(let i=0; i&lt;a.length; i++) {
    s += a[i];
  }
  console.log('Aa=', s);
}

function Ab(a, s=0) {
  let n = a.length;
  for(let i=0; i&lt;n; i++) {
    s += a[i];
  }
  console.log('Ab=', s);
}

function Ac(a, s=0) {
  for(let i=a.length; i--;) {
    s += a[i];
  }
  console.log('Ac=', s);
}

function Ad(a, s=0) {
  for(let x of a) {
    s += x;
  }
  console.log('Ad=', s);
}

function Ae(a, s=0) {
  for(let i in a) if (a.hasOwnProperty(i)) {
    s += a[i];
  }
  console.log('Ae=', s);
}

function Ba(a, s=0) {
  let i = -1;
  while(++i &lt; a.length) {
    s+= a[i];
  }
  console.log('Ba=', s);
}

function Bb(a, s=0) {
  let i = -1;
  let n = a.length;
  while(++i &lt; n) {
    s+= a[i];
  }
  console.log('Bb=', s);
}

function Bc(a, s=0) {
  let i = a.length;
  while(i--) {
    s += a[i];
  }
  console.log('Bc=', s);
}

function Bd(a, s=0) {
  let i = 0;
  do {
    s+= a[i]
  } while (++i &lt; a.length);
  console.log('Bd=', s);
}

function Be(a, s=0) {
  let i = 0;
  let n = a.length;
  do {
    s += a[i]
  } while (++i &lt; n);
  console.log('Be=', s);
}

function Bf(a, s=0) {
  const it = a.values(); 
  let e;
  while (!(e = it.next()).done) { 
    s+= e.value; 
  }
  console.log('Bf=', s);
}

function Ca(a, s=0) {
  a.map(x =&gt; { s+=x });
  console.log('Ca=', s);
}

function Cb(a, s=0) {
  a.forEach(x =&gt; { s+=x });
  console.log('Cb=', s);
}

function Cc(a, s=0) {
  a.every(x =&gt; (s += x, 1));
  console.log('Cc=', s);
}

function Cd(a, s=0) {
  a.filter(x =&gt; { s+=x });
  console.log('Cd=',s);
}

function Ce(a, s=0) {
  a.reduce((z, c) =&gt; { s+=c }, 0);
  console.log('Ce=', s);
}

function Cf(a, s=0) {
  a.reduceRight((z, c) =&gt; { s += c }, 0);
  console.log('Cf=', s);
}

function Cg(a, s=0) {
  a.some(x =&gt; { s += x } );
  console.log('Cg=', s);
}

function Ch(a, s=0) {
  Array.from(a, x=&gt; s += x);
  console.log('Cc=', s);
}


Aa(arr);
Ab(arr);
Ac(arr);
Ad(arr);
Ae(arr);

Ba(arr);
Bb(arr);
Bc(arr);
Bd(arr);
Be(arr);
Bf(arr);

Ca(arr);
Cb(arr);
Cc(arr);
Cd(arr);
Ce(arr);
Cf(arr);
Cg(arr);
Ch(arr);</code></pre>
<pre class="snippet-code-html lang-html prettyprint-override"><code>&lt;p style="color: red"&gt;This snippets only PRESENTS code used for benchmark - it not perform test itself&lt;/p&gt;</code></pre>
</div>
</div>
</p>

<p><strong>Cross browser results</strong></p>

<p>Results for all tested browsers</p>

<p><a href="https://i.stack.imgur.com/bSXp2.png" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/bSXp2.png" alt="Enter image description here"></a>browsers**</p>

<p><strong>Array with 10 elements</strong></p>

<p>Results for Chrome. You can perform the test on your machine <a href="https://jsbench.me/pxk4bicjru" rel="nofollow noreferrer">here</a>.</p>

<p><a href="https://i.stack.imgur.com/VuCMw.png" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/VuCMw.png" alt="Enter image description here"></a></p>

<p><strong>Array with 1,000,000 elements</strong></p>

<p>Results for Chrome. You can perform the test on your machine <a href="https://jsbench.me/9uk4bj4svg" rel="nofollow noreferrer">here</a></p>

<p><a href="https://i.stack.imgur.com/8JQf6.png" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/8JQf6.png" alt="Enter image description here"></a></p>
</tr></td><tr><td><p>You can use:</p>

<ol>
<li><p>ForEach</p>

<pre><code>theArray.forEach(function (array, index) {
    console.log(index);
    console.log(array);
});
</code></pre></li>
<li><p>for</p>

<pre><code>for(var i=0; i&lt;theArray.length; i++) {
    console.log(i)
}
</code></pre></li>
<li><p>map</p>

<pre><code>theArray.map(x =&gt; console.log(x));
</code></pre></li>
<li><p>map</p>

<pre><code>theArray.filter(x =&gt; console.log(x));
</code></pre></li>
</ol>

<p>And there are many others for iteration.</p>
</tr></td><tr><td><p>Using the <strong>grep</strong> function in jQuery, for example:</p>

<pre><code>$.grep([0, 1, 2], function(n, i) {
    return n &gt; 0;
});
</code></pre>
</tr></td><tr><td><p>As per the new updated feature ECMAScript 6 (ES6) and ECMAScript 2015, you can use the following options with loops:</p>

<blockquote>
  <p><strong>for loops</strong></p>
</blockquote>

<pre><code>for(var i = 0; i &lt; 5; i++){
  console.log(i);
}

// Output: 0,1,2,3,4
</code></pre>

<blockquote>
  <p><strong>for...in loops</strong></p>
</blockquote>

<pre><code>let obj = {"a":1, "b":2}

for(let k in obj){
  console.log(k)
}

// Output: a,b
</code></pre>

<blockquote>
  <p><strong>Array.forEach()</strong></p>
</blockquote>

<pre><code>let array = [1,2,3,4]

array.forEach((x) =&gt; {
  console.log(x);
})

// Output: 1,2,3,4
</code></pre>

<blockquote>
  <p><strong>for...of loops</strong></p>
</blockquote>

<pre><code>let array = [1,2,3,4]

for(let x of array){
  console.log(x);
}

// Output: 1,2,3,4
</code></pre>

<blockquote>
  <p><strong>while loops</strong></p>
</blockquote>

<pre><code>let x = 0

while(x &lt; 5){
  console.log(x)
  x++
}

// Output: 1,2,3,4
</code></pre>

<blockquote>
  <p><strong>do...while loops</strong></p>
</blockquote>

<pre><code>let x = 0

do{
  console.log(x)
  x++
}while(x &lt; 5)

// Output: 1,2,3,4
</code></pre>
</tr></td><tr><td><p>Suppose we have a array of subjects:</p>

<pre><code>  let ddl = new Array();
    if (subjects) {
      subjects.forEach(function (s) {ddl.push({"id": s.id,"label": s.name});});
    }
</code></pre>
</tr></td><tr><td><p>Javascript .map method iterates through each single element in the array. map() returns two arguments to callback function we provide theArray.map(item, index) . First argument is item which is currently iterating and second argument is the index of the item currently iterated.</p>
<pre><code>theArray.map((item, index) =&gt; console.log(index));
</code></pre>
</tr></td>